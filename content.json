{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-07-12T07:59:33.540Z","updated":"2021-07-12T07:59:33.540Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-07-12T07:59:33.542Z","updated":"2021-07-12T07:59:33.542Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-12T07:59:33.541Z","updated":"2021-07-12T07:59:33.541Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-07-12T07:59:33.541Z","updated":"2021-07-12T07:59:33.541Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-12T07:59:33.542Z","updated":"2021-07-12T07:59:33.542Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-12T07:59:33.543Z","updated":"2021-07-12T07:59:33.543Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-12T07:59:33.542Z","updated":"2021-07-12T07:59:33.542Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaSE17抽象类","slug":"JavaSE17抽象类","date":"2021-07-28T11:43:28.000Z","updated":"2021-07-28T11:49:54.304Z","comments":true,"path":"2021/07/28/JavaSE17抽象类/","link":"","permalink":"http://example.com/2021/07/28/JavaSE17%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"","text":"抽象类 abstract class场景12345678 public abstract class MockBusiness &#123; public void fun1()&#123; public abstract void fun2();// 依赖于第三方实现 public void fun3()&#123; &#125;&#125; 1.抽象类的使用场景：在业务实现中，有一个或多个功能需要依赖于第三方实现，则把该些功能设计为抽象方法，则该类就为抽象类。 2.定义：​ 含有抽象方法的类，就是抽象类 方法只有声明，没有实现（没有方法体）。 12abstract void grow();abstract void grow()&#123;&#125; // 有实现，空实现 error 3. 抽象类的定义以及使用规则：抽象类不一定含有抽象方法。 包含一个抽象方法的类必须是抽象类； 抽象类和抽象方法都要使用 abstract 关键字声明； 抽象方法只需声明不要实现； 抽象类必须被子类继承，子类(如果不是抽象类)必须覆写抽象类中的全部抽象方法； 抽象类不能被实例化，只能引用子类的对象。 向上转换 抽象类作为参数，传的是子类的对象 抽象类作为返回值，返回的是子类的对象。 示例：123456789101112131415161718public abstract class MockBusiness &#123; public MockBusiness()&#123;&#125; public void fun1()&#123; &#125; public void fun2()&#123; &#125; public abstract void fun3() ;//fun3() 依赖于其他类【子类】实现 public void fun4()&#123; &#125;&#125; 子类123456789101112/** * * alt + enter implements 父类的抽象方法 */public class A extends MockBusiness &#123; @Override public void fun3() &#123; //子类实现父类方法（语法上是重写） &#125;&#125; 1234public abstract class B extends MockBusiness &#123; //abstract fun3(); abstract void fun7();&#125; 1234567891011121314//实现子类C 要实现 所有父类 的所有抽象方法public class C extends B &#123; @Override void fun7() &#123; &#125; @Override public void fun3() &#123; &#125;&#125; 4. 注意：final abstract 不能结合使用​ final类不能有子类；​ 抽象类必须有子类；​ 抽象类中能定义构造方法么？ 答：能的；因为抽象类依然使用的是类的继承关系，且抽象类中 也存在各个属性，所以子类在实例化之前肯定是对父类进行的实例化的。 补充：​ 1.什么时候覆盖toString()方法？​ Person p = new Person();​ System.out.println(p);​ java会自动调用toString()方法；​ 但是结果不是我们想要的，因为Object类的toString()方法总是返回对象的​ 实现类类名 + @ + hashCode值。​ 我们希望的是能够打印出p的全名来，这时就希望能覆盖toString()方法， 因为重写toString方法之后，会优先调用自己的toString()方法。 应用中的抽象类：1若子类的方法实现都不一样，父类就没必要具体实现这些方法，父类把这些方法定义为抽象方法，子类根据自己的需求各自实现 123456789101112** * 银行账户 * 业务中：new Account() 错误 * new SavingAccount() * new CreditAccount() * */public abstract class Account &#123; //取款 储蓄账户、信用账户 取款方式都不一样， public abstract double withdrwa(double money);&#125; 123456public class SavingAccount extends Account &#123; @Override public double withdrwa(double money) &#123; return 0; &#125;&#125; 123456public class CreditAccount extends Account &#123; @Override public double withdrwa(double money) &#123; return 0; &#125;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE16克隆原型模式Prototype","slug":"JavaSE16克隆原型模式Prototype","date":"2021-07-28T11:41:41.000Z","updated":"2021-07-28T11:49:32.814Z","comments":true,"path":"2021/07/28/JavaSE16克隆原型模式Prototype/","link":"","permalink":"http://example.com/2021/07/28/JavaSE16%E5%85%8B%E9%9A%86%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8FPrototype/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*========================== 浅克隆 =========================================*/int a = 10;int b = a; // a 复制了一个副本，再赋值给bclass Student&#123; private String stuName; private int stuAge; public void setStuAge(int stuAge)&#123; // int stuAge = this.age 值传递 this.stuAge = stuAge; &#125; public void setStuName(String stuName)&#123; // stuName = &quot;smith&quot; this.stuName = stuName; &#125; public Student clone()&#123; // 浅克隆 Student stu = new Student(); stu.setName(this.name); stu.setAge(this.age); return stu; &#125;&#125;Student stu1 = new Student(&quot;tom&quot;,30);Student stu2 = stu1.clone(); /*========================== 深克隆 =========================================*/public class Customer &#123; private int custId; private String custEmail; private long custTelno; public Customer clone()&#123; Customer customer = new Customer(); customer.setCustId(this.custId); customer.setCustEmail(this.custEmail); customer.setCustTelno(this.custTelno); return customer; &#125;&#125;public class MyOrder &#123; private long orderId; private float orderMoney; private Customer customer; //引用数据类型（对象） public void setOrderId(long orderId)&#123; // long orderId = 3728322 ; this.orderId = orderId; &#125; public void setOrderMoney(float orderMoney)&#123; // float orderMoney = 5000 this.orderMoney = orderMoney; &#125; public void setCustomer( Customer customer)&#123; //Customer customer = customer1; this.customer = customer; &#125; public MyOrder clone()&#123;// 深克隆 MyOrder order = new MyOrder(); order.setOrderId(this.orderId); order.setOrderMoney(this.orderMoney); order.setCustomer( this.customer.clone()); // 实现 &#125; &#125;Customer customer1 = new Customer(7788,&quot;473839@qq.com&quot;,1834384332L);MyOrder order1 = new MyOrder(3728322L,5000,customer1);MyOrder order2 = order1.clone(); 123456原型模式 prototype (1)创建出原始对象的副本 new (2)原始对象的属性值也要复制给新对象 浅克隆：只复制按值传递的数据（基本数据类型、String）深克隆: 浅克隆 + 复制引用数据类型的属性（这些属性 自己再要 克隆） 1234567891011121314151617181920212223242526272829303132333435363738394041// 所有的订单都要实现 克隆 interface OrderClone&#123; public Order cloneOrder()&#123;&#125; // 通用订单abstract class Order implements OrderClone&#123; private String orderId; private String orderAddress; private int productNumber; //get,set &#125;class PersonOrder extends Order &#123; private String orderId; private int productNumber; private String orderAddress; public PersonOrder cloneOrder()&#123; PersonOrder order = new PersonOrder(); order.setOrderId(this.orderId); order.setOrderAddress(this.orderAddress); order.setProductNumber(1000); return order; &#125;&#125;class EnterpriseOrder&#123; private String orderId; private int productNumber; private String orderAddress; public EnterpriseOrder cloneOrder()&#123; EnterpriseOrder order = new EnterpriseOrder(); order.setOrderId(this.orderId); order.setOrderAddress(this.orderAddress); order.setProductNumber(1000); return order; &#125;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE15接口","slug":"JavaSE15接口","date":"2021-07-28T11:40:06.000Z","updated":"2021-07-28T11:49:25.208Z","comments":true,"path":"2021/07/28/JavaSE15接口/","link":"","permalink":"http://example.com/2021/07/28/JavaSE15%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"接口存在的意义：1、安全、严密性(封装)：接口是实现软件松耦合的重要手段，它描叙了系统对外的所有服务，而不涉及任何具体的实现细节。这样就比较安全、严密一些(一般软件服务商考虑的比较多)。 2、维护、拓展性：比如你要做一个画板程序，其中里面有一个面板类，主要负责绘画功能， 然后你就这样定义了这个类，可是在不久将来，你突然发现这个类满足不了你了，然后你又要重新设计这个类，更糟糕是你可能要放弃这个类，那么其他地方可能有引用他，这样修改起来很麻烦，如果你一开始定义一个接口，把绘制功能放在接口里，然后定义类时实现这个接口，然后你只要用这个接口去引用实现它的类就行了，以后要换的话只不过是引用另一个类而已，这样就达到维护、拓展的方便性。 3、简单、规范性：如果一个项目比较庞大， 那么就需要一个能理清所有业务的架构师来定义一些主要的接口， 这些接口不仅告诉开发人员你需要实现那些业务， 而且也将命名规范限制住了（防止一些开发人员随便命名导致别的程序员无法看明白）。 4、重要性：在Java语言中， abstract class 和interface 是支持抽象类定义的两种机制。正是由于这两种机制的存在，才赋予了Java强大的 面向对象能力。 接口定义：就是两个组件相互通信的约束或规则接口：12纯抽象类，是类能够做什么的合约，方法只有声明，没有实现。 是一种特殊类，里面全部是由全局常量和公共的抽象方法组成。 如何定义接口？1234interface 接口名称&#123; // 全局常量; // 抽象方法;1&#125; 123456789101112131415 Ps:接口中定义的成员变量 ，成员方法 public interface A&#123; public static final int AGE= 18; public abstract void fly(); &#125; 等价于：（完全一样） public interface A&#123; int i= 1; void fly(); &#125; // 注意： final、private、static、protected void fly();//非法定义接口的方法 示例： 接口：12345678public interface Cpu &#123; //全局常量 public static final int PRODUCT_YEAR = 2019; //抽象方法 public abstract void cpuRun(); public abstract void cpuStop();&#125; 实现子类 HpCpu1234567891011public class HpCpu implements Cpu &#123; @Override public void cpuRun() &#123; &#125; @Override public void cpuStop() &#123; &#125;&#125; 实现子类 HuaWeiCpu123456789101112//实现CPU 必须具备的功能public class HuaWeiCpu implements Cpu&#123; @Override public void cpuRun() &#123; &#125; @Override public void cpuStop() &#123; &#125;&#125; 接口使用注意：12345678910111213141516171819202122231. 接口的使用也必须有子类，子类必须覆盖全部抽象方法，implements关键字实现， 一个子类可以实现多个接口，则子类如果不是抽象类的话， 一定要覆写接口中的全部方法。2. 继承抽象类实现接口: 一个子类可以同时继承抽象类和实现接口 语法： class 子类 extends 类 implements 接口A，接口B...&#123;&#125; 3.接口的继承： 一个接口不能继承抽象类，但是能通过extends关键字同时继承多个接口，实现 接口的多继承。 语法： interface 子接口 extends 父接口A,父接口B,...&#123;&#125; 接口中的抽象方法可以不加入abstract,而抽象类中的抽象方法必须有abstract关键字声明；4.一个类只能继承一个父类，但是可以同时实现多个接口； 一个接口可以同时继承多个接口，以实现接口的多继承； 接口和抽象类一样，都必须依靠子类； 一个抽象类可以实现多个接口，但是一个接口不能继承一个抽象类。 5、如果某个类实现了某个接口，那么我们就说，这个类具备这个接口所定义的功能。从语法角度来说，和继承类似6、接口不能被实例化，只能引用子类的对象（接口作为参数或者返回值类型）7、什么时候使用抽象类和接口？ 什么时候使用抽象类和接口？1234567891011121314151617应用： 一个类中一部分功能需要依赖于其他类实现，则把这些方法定义为抽象方法，该类 为 抽象类 组件与组件之间（模块与模块之间）的通讯，使用接口 (保证业务内部实现不被暴露，降低模块之间的耦合性) 语法： public abstract class A&#123; public void fun1()&#123;&#125; public abstract void fun2(); &#125; public interface B&#123; //全局常量 public static final int X = 10; //抽象方法 public abstract void fun3(); &#125; 123456789101112131415161718192021222324252627282930313233343536public interface A &#123; public void fun1();&#125; interface B&#123; public void fun2();&#125;//接口 可以多继承interface C extends A,B&#123; public void fun3();&#125;class D&#123;&#125;// 继承 + 实现多接口class E extends D implements A,B,C&#123; @Override public void fun1() &#123; &#125; @Override public void fun2() &#123; &#125; @Override public void fun3() &#123; &#125;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE14单例模式","slug":"JavaSE14单例模式","date":"2021-07-28T11:39:17.000Z","updated":"2021-07-28T11:49:16.776Z","comments":true,"path":"2021/07/28/JavaSE14单例模式/","link":"","permalink":"http://example.com/2021/07/28/JavaSE14%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式 Singleton在内存中该对象只有一份 （1 ）饿汉模式：1在Bank类加载的时候，Bank对象就创建好了 （2）懒汉模式：1外部调用getBankInstance() (外部 什么时候需要使用bank对象的时候)， 才实例化Bank对象，尤其是该对象是重量级对象（ 实例化需要很多资源[网络资源，内存，时间....] ）=====&gt; 延迟实例化对象 （ 懒加载 lazy ） 饿汉模式示例： 12345678910public class Bank &#123;//student product private static Bank bank = new Bank(); private Bank()&#123;&#125; public static Bank getBankInstance()&#123; return bank; &#125;&#125; 懒汉模式示例：","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE13参数传递","slug":"JavaSE13参数传递","date":"2021-07-28T11:37:21.000Z","updated":"2021-07-28T11:49:10.849Z","comments":true,"path":"2021/07/28/JavaSE13参数传递/","link":"","permalink":"http://example.com/2021/07/28/JavaSE13%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/","excerpt":"","text":"参数传递1. 值传递 : 形参 是基本数据类型123456基本数据类型 作为形参，形参值发生改变，实际参数变量不会发生改变【本质（原因）】 ：基本数据类型的赋值 ，传的是 值的副本。 int a =10; int b = a; // 传的是 值的副本， a,b 分别指向各自的值10 b = 90; //a = 10; 2. 地址传递 ： 形参 是 引用数据类型1234567引用数据类型 作为形参，形参的值发生改变，实际参数变量也改变【本质（愿意）】： 引用数据类型的赋值，传的是 堆地址Book b1 = new Book(&quot;四大名著&quot;，199.9f);Book b2 = b1; // 传的是 堆地址，b1,b2 指向同一块 堆内存b2.setBookName(&quot;毛泽东选集&quot;);//b1.getBookName(); --- &quot;毛泽东选集&quot; 示例：123456789101112131415161718192021222324252627282930313233343536 public class DataTransfer&#123; public static void main(String[] args)&#123; DataTransfer dt = new DataTransfer(); int a = 10; int b = 20; dt.fun1(a,b); Systm.out.println(&quot;a = &quot; + a + &quot;, b = &quot; + b); Book book = new Book(&quot;四大名著全套&quot;,199.9f); dt.fun2(book); Systm.out.println(&quot;书的名称：&quot;+ book.getBookName() + &quot;, 书的价格：&quot; + book.getBookPrice());&#125;public void fun1(int a, int b)&#123; a = 30; b = 40; &#125; public void fun2(Book book)&#123; book.setBookName(&quot;毛泽东选集&quot;); book.setBookPrice(99.9f); &#125; &#125;class Book&#123; private String bookName;private float bookPrice;public Book()&#123;&#125;public Book(String bookName,float bookPrice)&#123; this.bookName = bookName; this.bookPrice = bookPrice; &#125;//get,set方法省略&#125; 值传递 地址传递​","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE12重写","slug":"JavaSE12重写","date":"2021-07-28T11:29:34.000Z","updated":"2021-07-28T11:48:52.082Z","comments":true,"path":"2021/07/28/JavaSE12重写/","link":"","permalink":"http://example.com/2021/07/28/JavaSE12%E9%87%8D%E5%86%99/","excerpt":"","text":"二、方法重写 override ：在继承关系中使用场合： 在继承关系中,子类的方法 与父类内部实现表现的不一样 语法：123456789101112131. 方法名、参数列表与 父类一致2. 方法体（业务实现）与父类不一样(1)参数列表要与父类完全一致(2)返回值： 父类返回值 void , 子类必须是void 父类返回值 基本数据类型，子类返回值 必须完全一致 父类返回值 引用数据类型，子类返回值 完全一致 或者是 父类返回值的子类（3）public &gt; protected &gt; 缺省 &gt; private 子类的访问权限 不能比 父类更严格 123456789101112131415public class Animal &#123; public void run()&#123; System.out.println( &quot; an animal is running&quot;); &#125;&#125;public class Cat extends Animal &#123; // 方法重写 public void run()&#123; System.out.println(&quot;a cat is running&quot;); &#125;&#125; 重写 override又叫做：覆盖、复写 什么场合中要使用到方法重写？1继承关系中，父类的方法 无法满足子类的需求（表现在方法内部实现不满足），就需要子类重写父类的方法 语法要求：1234567891. 继承关系中2. 方法名、参数表列 必须与父类完全一致3. 返回值 若是void 或 基本数据类型，必须与父类 返回值完全一致 若是引用数据类型，必须与父类返回值一致 或 是父类返回值的子类4. 访问权限 子类的方法访问权限 不能比父类更严格5. 异常 子类的方法中的异常 与父类方法异常一致 或 父类方法异常的子类 访问权限 123456public ： 所有类都能访问private ：只有本类能访问缺省 ： 只能本包能访问protected ： 只能本包能访问,不同包中的子类也能访问public &gt; protected &gt; 缺省 &gt; private 1234567891011121314public class A &#123; public void study()&#123; &#125;&#125;class B extends A&#123; public void study()&#123; &#125;&#125; @Override该注解Annotation 的作用是： 检查当前方法结构是否满足 重写要求","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE11static","slug":"JavaSE11static","date":"2021-07-28T11:06:21.000Z","updated":"2021-07-28T11:48:44.254Z","comments":true,"path":"2021/07/28/JavaSE11static/","link":"","permalink":"http://example.com/2021/07/28/JavaSE11static/","excerpt":"","text":"static1. Java的内存​ java把内存分为栈内存和堆内存,数据区，代码区，​ 栈内存用来存放一些基本类型的变量和数组及对象的引用变量，而堆内存主要是来放置对象的。​ 用static的修饰的变量和方法，实际上是指定了这些变量和方法在内存中的“固定位置”－data storage。 2. static修饰的成员​ 类名.静态方法名(参数列表…)​ 类名.静态变量名 按照是否静态的对类成员变量进行分类可分两种： 一种是被static修饰的变量，叫静态变量或类变量； 另一种是没有被static修饰的变量，叫非静态变量(实例变量)。 全局常量： static + final static final ADDRESS = &quot;suzhou&quot;; 两者的区别是： 对于类变量在内存中只有数据一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成static变量的内存分配， 用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。 静态变量属于类,为该类所有对象所分享,在程序开始执行前就分配内存空间, 如果前面加上final,功能类似全局常量,不可以修改其值.比如圆周率 。 对于实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。 一般在需要实现以下两个功能时使用staitc 静态变量： 在对象之间共享值时 方便访问变量、方法时（工具类中使用较多） static代码块​ static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的​ 先后顺序依次执行它们，每个代码块只会被执行一次。 为什么要使用static / 什么场合使用 * 1.一个方法没有对象意义（一个类中不存在对象的实际意义）， 该方法不需要对象来访问，通过 类名访问 类名.方法名(..) EncryptionUtil、 Math : 没有实例的意义 Math 工具类: 仅仅只是为了实现一些数学中的算法操作而封装了一系列方法 abs(-9), max(78,43) * 2.该变量属于类级别，归这一类群体的共性 类变量： 类名.变量名 案例分析：123456789101112131415161718192021222324252627new Son() : 1 类加载： a. static 变量 ， b.static 代码块 2.实例化对象 new Son() a.初始化对象的属性， b.执行实例代码块 c.构造函数方法体class Son &#123;// static int age = 20; float height = 175; static&#123; // Son类加载的时候 执行static 代码块 System.out.println(&quot;Son static&quot;); System.out.println(&quot;Son static age = &quot; + age);// 20 &#125; //代码块 对象 ：实例代码块 &#123; System.out.println(&quot;son的代码块&quot;); System.out.println(&quot;son的代码块 height = &quot; + height);//175 &#125; public Son()&#123; System.out.println(&quot;son的构造函数 &quot; + height); System.out.println(&quot;Son的构造函数&quot;); &#125;&#125; 继承关系中123继承关系中： 先加载父类、后加载子类 加载Son.class// new Son() ​ 12345678910111213141516171819class GrandFather&#123; static&#123; System.out.println(&quot;GrandFather static&quot;); &#125; &#125;class Father extends GrandFather&#123; static&#123; System.out.println(&quot;Father static&quot;); &#125;&#125;class Son extends Father&#123; static&#123; System.out.println(&quot;Son static&quot;); &#125;&#125; 继承关系中： 先加载父类、后加载子类 ``` 父类 static 类变量、static {} 子类 static 类变量、static {} 父类初始化实例变量、普通代码块、构造函数 子类初始化实例变量、普通代码块、构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445 ```javaclass Father &#123; static int age = 40; String name =&quot;Tony&quot;; static&#123; System.out.println(&quot;Father static&quot;); &#125; &#123; System.out.println(&quot;Father 普通代码块&quot;); &#125; public Father()&#123; System.out.println(&quot;Father无参构造函数&quot;); &#125;&#125;class Son extends Father&#123; static int age = 20; String name =&quot;Tommy&quot;; static&#123; System.out.println(&quot;Son static&quot;); &#125; &#123; System.out.println(&quot;Son 普通代码块&quot;); &#125; public Son()&#123; //super(); System.out.println(&quot;Son无参构造函数&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; new Son(); &#125; &#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE10final与访问权限","slug":"JavaSE10final与访问权限","date":"2021-07-28T11:04:13.000Z","updated":"2021-07-28T11:48:35.910Z","comments":true,"path":"2021/07/28/JavaSE10final与访问权限/","link":"","permalink":"http://example.com/2021/07/28/JavaSE10final%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/","excerpt":"","text":"一、final 关键字1. 常量 constant : 值是固定的1final String SCHOOL_NAME = &quot;苏州大学&quot;; 2. final 修饰的类 : 最终类 【不能有子类】​ 该类所有的属性方法不能继承给其他类，从而保证当前类的安全性 3. final 修饰的方法 子类不能再重写该方法 访问权限1234public ： 公共的，其他类都能访问prviate : 私有的，只有本类能访问缺省: 只有本包能访问protected： 只有本包能访问，还有不同包中的子类 final123451. final 修饰变量：常量，值不能改变2. final 修饰类： 最终类，不能有子类（太监类） 防止该类的属性或方法 被别的类继承3. final修饰方法：最终方法，方法不能被子类重写（防止方法被子类重写）","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE09继承与instanceof","slug":"JavaSE09继承与instanceof","date":"2021-07-28T11:01:34.000Z","updated":"2021-07-28T11:34:44.166Z","comments":true,"path":"2021/07/28/JavaSE09继承与instanceof/","link":"","permalink":"http://example.com/2021/07/28/JavaSE09%E7%BB%A7%E6%89%BF%E4%B8%8Einstanceof/","excerpt":"","text":"继承为什么要使用继承？123多个在业务中相类似的类 ， 有共同的属性与功能，可以将指这些属性与功能 封装 到 一个公共的类中，该类就是父类其他的类 中的属性与功能 从父类中继承过来，这样 大大减少了 代码的冗余性。 语法12class A&#123;&#125;class B extends A&#123;&#125; Java是单继承，即 只有一个直接父类Object 是所有类的超级父类，根类，基类父类所有的属性与方法 是不是 都能被子类继承？1234567891011121314不是，需要看访问权限class A&#123; private int x; // x 不能被子类继承，x 只能被 本类A 访问 public int y; // y 被子类继承，因为 y的访问权限是public public void fun1()&#123;&#125; // 能被子类继承 private void fun2()&#123;&#125; //不能被子类继承&#125;class B extends A&#123; //继承了A 中的 y成员变量 //继承了A 中的 fun1成员方法&#125; 创建子类对象12345678910111213141516171819202122232425262728293031class A&#123; public A()&#123; System.ou.println(&quot;A 父类的 无参构造函数&quot;) &#125; &#125;class B extends A&#123; public B()&#123; super(); //默认隐藏 调用父类的无参构造函数 A() System.ou.println(&quot;B 子类的 无参构造函数&quot;) &#125; &#125;//测试类public class Test&#123; public static void main(String[] args)&#123; new B(); &#125; /* 1. new : 在堆中开辟一块内存【创建对象】 2. B()&#123;&#125; : (1) 初始化属性 （2）执行构造函数方法体 */ &#125; 继承与构造函数1234567891011121314151617181920212223242526272829303132//父类class Father&#123; public Father()&#123;&#125; public Father(String name,int age)&#123;...&#125;&#125;//子类class Son exetnds Father&#123; public Son()&#123; super();//默认访问父类 无参构造函数 &#125; public Son(String name)&#123; super();//默认访问父类 无参构造函数 &#125; public Son(String name,int age)&#123; super(name,age); &#125; &#125;/* 总结： 1. 子类的构造函数中 默认会调用父类 无参构造函数 super(); 2. 在子类构造函数中 访问 父类构造函数 super(..), 这行代码必须放在第一行*/ 4.继承 “is a” 的关系 狗是一种宠物 , 猫也是一种宠物 dog is a pat 声明的格式 在Java 中 – extends关键字 1234567891011 public class Manager extends Employee &#123;…&#125; public Manager()&#123; super(); &#125;注意：Java中只有单一继承。Object类是所有类的根类。构造方法不能被继承方法和属性可被继承子类构造方法隐式调用父类的默认构造方法在子类的构造函数也可以显式的调用父类的构造, 使用super(…)，但是必须是第一个行有效 5.(1) 父类引用子类对象 Pet p1 = new Dog() (2)子类 不能接收父类对象 Dog d2 = new Pet(); (3) 可以通过强制类型转换 将父类对象赋值给子类，转换之前一定要使用instanceof来判断，防止类型转换异常ClassCastException if(pet instanceof Dog){//false|true, 判断 pet对象 是否是Dog类型（即 判断 pet1 对象 是不是可以用Dog来接收 ）Dog d = (Dog)pet; instanceof1234dog instanceof Dog// dog 对象 是不是Dog 类型//等价于 Dog xx = dog; 多态12//1. 父类引用子类对象 //2. 子类重写父类方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/***********************************父类 引用 子类对象******************************/class Pet&#123;&#125;class Dog extends Pet&#123;&#125;Pet pet = new Dog(); // 父类 引用子类对象 Dog dog = new Dog(); Dog dog2 = (Dog)pet;// OK ， pet 真正在内存中 是DogPet pet1 = new Pet();Dog dog3 = (Dog)pet1; // 错误的 ClassCastException为了避免ClassCastException,一般在 父类转换成子类对象前，都要用instanceof 判断if(pet1 instanceof Dog)&#123; Dog dog3 = (Dog)pet1;&#125;/** 子类 或 父类 = new 子类(); 子类类型 = new 父类(); 错误 父类 引用子类对象 父类对象 强制类型 转换成 子类类型前，一定要用 instanceof 判断，避免ClassCastException*//*************************************多态*************************************/public class User&#123; public void watchVideo()&#123; System.out.println(&quot;user在看视频&quot;); &#125;&#125;public class Vip extends User&#123; //重写 public void watchVideo()&#123; System.out.println(&quot;vip在看视频&quot;); &#125;&#125; //1. 父类引用子类对象 //2. 子类重写父类方法 User userVip = new Vip(); userVip.watchVideo(); // 运行的是 子类的方法","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE08super关键字","slug":"JavaSE08super关键字","date":"2021-07-28T11:01:00.000Z","updated":"2021-07-28T11:52:25.037Z","comments":true,"path":"2021/07/28/JavaSE08super关键字/","link":"","permalink":"http://example.com/2021/07/28/JavaSE08super%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"super关键字 super 指向父类对象 super(): 调用父类的构造函数,需放在构造方法内第一行。 super.属性: 访问父类对象的实例成员。 super.方法: 访问父类对象的方法。 注：属性没有覆盖(重写) 注意：this 和super的区别 super调用父类的属性，方法： super.方法 ， super.属性 super(); this调用属性，方法： this.方法 ， this.属性 构造函数中的this： get，set中的this this 和super的区别： 属性访问 调用构造函数 特殊 this 访问本类中的属性,方法. 如果本类没有此属性就在父类中继续查找 调用本类构造，必须放在构造函数的首行 表示当前对象 super 访问父类中的属性,方法 调用父类构造，必须放在子类的首行 super 关键字super ：父类对象 this ： 当前对象 继承与构造函数1234567891011121314151617181920212223242526272829303132//父类class Father&#123; public Father()&#123;&#125; public Father(String name,int age)&#123;...&#125;&#125;//子类class Son exetnds Father&#123; public Son()&#123; super();//默认访问父类 无参构造函数 &#125; public Son(String name)&#123; super();//默认访问父类 无参构造函数 &#125; public Son(String name,int age)&#123; super(name,age); &#125; &#125;/* 总结： 1. 子类的构造函数中 默认会调用父类 无参构造函数 super(); 2. 在子类构造函数中 访问 父类构造函数 super(..), 这行代码必须放在第一行*/","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE07this关键字","slug":"JavaSE07this关键字","date":"2021-07-22T08:50:32.000Z","updated":"2021-07-28T11:48:11.522Z","comments":true,"path":"2021/07/22/JavaSE07this关键字/","link":"","permalink":"http://example.com/2021/07/22/JavaSE07this%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"this关键字(1) this关键字的用法： a. 直接写this：代表当前对象。 b. this.XXX：访问当前对象的实例成员。仅当方法中定义有与属性同名的局部变量时，在方法中访问类的属性才需要用this.XXX。 c. this( )：调用本类的其他构造方法，这种用法只能出现在构造方法的第一行。 (2) 调用 this(…) 必须是构造函数里的第一个语句; (3). 说明在什么情况下需要用到this： 第一、通过this调用另一个构造方法，用法是this(参数列表)，这个仅仅在类的构造方法中，别的地方不能这么用。 第二、函数参数或者函数中的局部变量和成员变量同名的情况下，成员变量被屏蔽，此时要访问成员变量则需要用“this.成员变量名”的方式来引用成员变量。 第三、在函数中，需要引用该函所属类的当前对象时候，直接用this。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE06构造函数","slug":"JavaSE06构造函数","date":"2021-07-20T10:52:47.000Z","updated":"2021-07-28T11:47:58.855Z","comments":true,"path":"2021/07/20/JavaSE06构造函数/","link":"","permalink":"http://example.com/2021/07/20/JavaSE06%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","excerpt":"","text":"构造函数 Constructor作用：初始化对象语法：无参构造函数 （默认隐藏）有参构造函数注意： ``` 无参构造函数 默认隐藏 有了有参构造函数，默认会把无参构造函数 覆盖掉， 若还想调用 无参构造函数，则 必须把 无参构造函数 显式的写出来123456789101112 #### 示例：```javapublic class Computer &#123; public Computer()&#123;...&#125; // 无参构造函数 （默认隐藏） public Computer(String computerBrand)&#123;...&#125; //有参构造函数 public Computer(String computerBrand, String computerColor)&#123;...&#125; //有参构造函数 public Computer(String computerBrand, String computerColor, double computerWeight)&#123;...&#125; //有参构造函数&#125; 创建对象的内存实现过程(1) 通过无参构造函数 实例化 对象12345678910111213141516171819public class Computer &#123; private String computerBrand ;//电脑品牌名称 private String computerColor; //电脑颜色 private double computerWeight;//电脑重量 //默认隐藏 构造函数 Constructor //无参构造函数 public Computer()&#123;&#125;&#125;//测试类public class ComputerTest &#123; public static void main(String[] args) &#123; Computer computer1 = new Computer(); // new : 创建对象，在堆开辟一块内存 // Computer() ： 调用无参构造函数 &#125;&#125; （2）通过有参构造函数 实例化 对象123456789101112131415161718192021222324public class Computer &#123; private String computerBrand ;//电脑品牌名称 private String computerColor; //电脑颜色 private double computerWeight;//电脑重量 //默认隐藏 构造函数 Constructor //无参构造函数 public Computer()&#123;&#125; public Computer(String computerBrand, String computerColor, double computerWeight) &#123; this.computerBrand = computerBrand; this.computerColor = computerColor; this.computerWeight = computerWeight; &#125;&#125;//测试类public class ComputerTest &#123; public static void main(String[] args) &#123; Computer computer2= new Computer(&quot;ThinkPad&quot;,&quot;White&quot;,49.9); &#125;&#125; 构造函数也构成方法重载 1234567public Computer()&#123;&#125;public Computer(String computerBrand, String computerColor, double computerWeight) &#123; this.computerBrand = computerBrand; this.computerColor = computerColor; this.computerWeight = computerWeight;&#125; 构造函数 Constructor(构造方法，构造器)**(1). 构造函数的作用：可以用于给对象进行初始化。 当一个类中没有定义构造函数时，那么系统会默认给该类加入一个无参的构造函数。 当在类中自定义了有参构造函数后，默认的构造函数就没有了。 如需还要使用无参构造函数，必须显式的定义出来。 (2). 构造函数必须与类同名 只能被public private protected修饰，没有返回值 (3)构造的粗略过程如下 a、分配对象空间，并将对象中成员初始化为0或者null等，java不允许用户操纵一个不定值的对象。 b、初始化属性 c、执行构造函数方法体 d、将对象名指向堆内存中 (4).构造函数重载 有参构造函数、无参构造函数示例：12345678910111213141516171819202122232425262728/** * 构造函数 Constructor * (构造方法，构造器) * 作用: 初始化对象 */public class Student &#123; private int stuNo;//学号 private String stuName; //姓名 //无参构造函数 constructor ：默认隐藏 public Student()&#123; System.out.println(&quot;构造函数 constructor&quot;); &#125; //有参构造函数 public Student(int stuNo,String stuName)&#123; this.stuNo = stuNo; this.stuName = stuName; System.out.println(&quot;student有参构造函数&quot;); &#125; //void 没有返回值 public void fun1()&#123; &#125; //方法有返回值 public boolean fun2()&#123; int row = 0; return row &gt; 1; &#125;&#125; 测试类123456789101112public static void main(String[] args) &#123; //1. new : 创建对象，开辟堆内存 //2. Student() 构造函数： （1）初始化属性 ： stuNo = 0, stuName = null // （2）执行构造函数方法体 Student stu1 = new Student(); stu1.setStuNo(7788); // setStuNo(..) &#123; this.stuNo = stuNo; &#125; stu1.setStuName(&quot;张南顶&quot;); //setStuName(..)&#123; this.stuName = stuName; &#125; Student stu2 = new Student(7788,&quot;张南顶&quot;); System.out.println(&quot;stu2 no ;&quot; + stu2.getStuNo()); System.out.println(&quot;stu2 name ;&quot; + stu2.getStuName());&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE05方法重载","slug":"JavaSE05方法重载","date":"2021-07-20T10:52:40.000Z","updated":"2021-07-28T11:51:55.534Z","comments":true,"path":"2021/07/20/JavaSE05方法重载/","link":"","permalink":"http://example.com/2021/07/20/JavaSE05%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/","excerpt":"","text":"一、方法重载 overload语法123456781. 方法名相同2. 参数列表不一样 a. 个数不一样 b. 类型不一样 c. 顺序不一样注意： (1)、参数类型的自动类型提升 (2)、编译器会根据参数在编译时确定运行时执行哪个方法。 理解：12调用某一方法的时候，发现该方法的参数列表不满足需求，那么就需要重新创建同名的方法，参数列表不一样 =====&gt; 即实现 【方法重载】 示例一：12345678910111213141516171819202122232425262728293031323334 public int add(int x,int y)&#123; return x+y; &#125; public int add(int x,int y,int z)&#123; return x+y +z; &#125; public double add(double x,double y)&#123; return x+y; &#125; public double add(int x,double y)&#123; return x+y; &#125; public double add(double x,int y)&#123; return x+y; &#125; public double add(float x)&#123; return x; &#125; public void add(char x)&#123; &#125; public void add(int x)&#123; &#125;//add方法调用 computer1.add(10,20); computer1.add(10,30.7); computer1.add(&#x27;a&#x27;); computer1.add(10,20,30); 方法重载示例：12345678910111213Arrays.sort(int[] a); // 方法名相同，参数类型不一样Arrays.sort(char[] a);Arrays.sort(float[] a);Arrays.fill(int[] a, int val) &#123;...&#125; // 方法名相同，参数个数、类型不一样Arrays.fill(double[] a, int fromIndex, int toIndex,double val)&#123;...&#125;public static void add(int x, int y)&#123; &#125;public static void add(float x,float y)&#123; &#125;public static void add(int a,int b,int c)&#123; &#125;public static void add(int a, float b)&#123;&#125;public static void add(float a, int b)&#123;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE04面向对象编程","slug":"JavaSE04面向对象编程","date":"2021-07-20T10:50:54.000Z","updated":"2021-07-20T10:52:18.724Z","comments":true,"path":"2021/07/20/JavaSE04面向对象编程/","link":"","permalink":"http://example.com/2021/07/20/JavaSE04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","excerpt":"","text":"面向对象编程OOP :Object Oriented Programming1. 类与对象12类： 是群体性概念，描述一类事物共有的属性与行为对象：是类在现实生活中 一个个实实在在的个体 示例：1234567891011121314151617181920212223/** 用于描述学生信息 * 学生共有的属性与行为*/public class Student&#123; /** * 学生姓名 */ public String sname; /** * 学生手机号 */ public long stuTelno; /** * 学生年龄 */ public int studentAge; /** * 学生专业 */ public String studentMajor; &#125; StudentTest12345678910111213141516171819202122232425public class StudentTest &#123; public static void main(String[] args) &#123; //描述我与同桌两个学生个体 //创建学生对象 //数据类型 变量名 = 值; int a = 10; //数据类型 对象名 = 值; Student student1 = new Student(); student1.studentName = &quot;SunShenshen&quot;; student1.studentAge = 20; student1.studentMajor=&quot;计算机&quot;; student1.studentTelno = 184398404L; Student student2 = new Student(); student2.studentName = &quot;LiuBaohe&quot;; student2.studentAge = 21; student2.studentMajor = &quot;计算机&quot;; student2.studentTelno = 184934893L; System.out.println(student2.studentMajor); &#125; &#125; 内存分配图 （重点） 存在的问题12耦合性较高、可维护性比较差 ： 修改Student成员变量名，其他类中的属性 也要修改安全性较低： Student类的元信息（属性）暴露出去 解决：1234561. 访问权限* public ： 公共的，所有的类都能访问* private : 私有的， 只有本类能访问 2.set 方法 给属性赋值 get 方法 获得属性值 Student1234567891011121314151617181920212223242526272829303132333435363738public class Student &#123; /** * 学生姓名 */ private String sname; /** * 学生手机号 */ private long stuTelno; /** * 学生年龄 */ private int studentAge; /** * 学生专业 */ private String studentMajor; //给学生姓名赋值 public void setStuName(String name)&#123; sname = name; &#125; //给学生年龄赋值 public void setStudentAge(int age)&#123; studentAge = age; &#125; //给学生手机号赋值 public void setStudentTelno(long telno)&#123; stuTelno = telno; &#125; //给学生专业赋值 public void setStudentMajor(String major)&#123; studentMajor = major; &#125;&#125; StudentTest123456789101112 Student student1 = new Student(); student1.setStuName(&quot;SunShenshen&quot;); student1.setStudentAge(20); student1.setStudentMajor(&quot;计算机&quot;); student1.setStudentTelno(138938493493L);/* public void setStuName(String name)&#123; stuName = name; // 等价于 student =name = &quot;SunShenshen&quot; &#125; */ 语法： 12345678910创建对象// 类类型 Student s1 = new Student();类类型 对象名 = new 类类型(); //访问对象的属性 s1.studentName = &quot;Tom&quot; 对象名.属性名 //访问对象的方法 s1.setName(&quot;Tom&quot;) 对象名.方法名 封装​ 数据的安全性、耦合性 ​ 具体体现: 访问权限（public - private ） ​ set 、get this关键字123this : 当前对象this.属性 // 当前对象的某一个属性this.方法 // 当前对象的方法 方法123456789101112131415161718结构访问权限 + [static | final] + 返回值 + 方法名 + 参数列表 + 异常 + 方法体目前需要掌握的：访问权限 + 返回值 + 方法名 + 参数列表 + 方法体public class Student&#123; public int getAge()&#123; &#125; public void setAge(int age)&#123; // age 形式参数（形参），作用域范围 就当前方法 &#125;&#125; Student stu = new Student();stu.setAge(10); //实际参数，实参 面向对象再次理解123456789101112131415161718192021222324252627282930313233343536373839public class Phone&#123; private String phoneName;//手机名称 private float phonePrice;//手机价格 //set get //打电话 public void call()&#123; &#125;&#125;public class PhineTest&#123; public static void main(String[] args)&#123; // 手机所有的参数信息 都是从 手机对象 身上获得的 Phone p1 = new Phone(); p1.setPhoneName(&quot;Huawei P30&quot;); p1.setPhonePrice(4288); String pname = p1.getPhoneName(); float pprice = p1.getPhonePrice(); p1.call(); // 这个p1 华为手机 调用 打电话功能 对象的行为 Phone p2 = new Phone(); p2.setPhoneName(&quot;Iphone X&quot;); p2.setPhonePrice(5288); String pname = p2.getPhoneName(); float pprice = p2.getPhonePrice(); p2.call(); // 这个p2 iphone手机 调用 打电话功能 对象的行为 &#125; &#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE03常用排序算法","slug":"JavaSE03常用排序算法","date":"2021-07-19T11:40:04.000Z","updated":"2021-07-19T11:43:01.731Z","comments":true,"path":"2021/07/19/JavaSE03常用排序算法/","link":"","permalink":"http://example.com/2021/07/19/JavaSE03%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"常用排序算法面试中经常会被问到或现场写：冒泡、快速 （1）冒泡排序 Bubble Sort ```java/** 冒泡排序 @param arr 需要排序的数组*/public void bubbleSort(int[] arr){for(int i= 0;i&lt;arr.length;i++){for(int j = 0;j&lt;arr.length-i-1;j++)&#123; if(arr[j] &gt; arr[j+1])&#123; int temp; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; System.out.print(arr[i] + &quot;,&quot;); }}123456789101112131415161718192021222324252627282930313233343536373839404142434445----------#### （2）插入排序 Insert Sort ```java /** - 插入排序 - @param arr 需要排序的数组 */ public static void insertSort(int[] arr)&#123; int length=arr.length; //数组长度 int j; //当前值的位置 int i; //指向j前的位置 int key; //当前要进行插入排序的值 //61,19,56,37,20 ,66,50,34,37,3 // 19 37 56 61 20 /* key = 20 j =4; i = j-1 = 3 a[4] = a[3] 19 37 56 61 61 i = 2 56 &gt; 20 a[3]=a[2] 19 37 56 56 61 i = 1 37 &gt; 20 a[2] = a[1] 19 37 37 56 61 i =0 19 &gt; 20 false a[1] = key =20 */ //从数组的第二个位置开始遍历值 19 37 56 61 20 for(j=1;j&lt;length;j++)&#123; key=arr[j]; i=j-1; //a[i]比当前值大时，a[i]后移一位,空出i的位置，好让下一次循环的值后移 while(i&gt;=0 &amp;&amp; arr[i]&gt;key)&#123; arr[i+1]=arr[i]; //将a[i]值后移 i--; //i前移 &#125;//跳出循环(找到要插入的中间位置或已遍历到0下标) arr[i+1]=key; //将当前值插入 &#125; &#125; （3）选择排序 Select Sort12345678910111213141516171819/**- 选择排序 - @param arr 需要排序的数组 */ public static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; int min = i; // 将当前下标定义为最小值下标 for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[min] &gt; arr[j]) &#123; /* 如果有小于当前最小值的关键字 */ min = j; /* 将此关键字的下标赋值给min */ &#125; &#125; if (i != min) &#123;/* 若min不等于i，说明找到最小值，交换 */ int tmp = arr[min]; arr[min] = arr[i]; arr[i] = tmp; &#125; &#125; &#125; （4）归并排序 Merge Sort123456789101112131415161718192021222324252627282930313233343536/** - 归并排序 - @param a 需要排序的数组 - @param s 第一个有序表的起始下标 - @param m 第二个有序表的起始下标 - @param t 第二个有序表的结束下标 - */ public static void merge(int[] arr, int s, int m, int t) &#123; int[] tmp = new int[t - s + 1]; int i = s, j = m, k = 0; while (i &lt; m &amp;&amp; j &lt;= t) &#123; if (arr[i] &lt;= arr[j]) &#123; tmp[k] = arr[i]; k++; i++; &#125; else &#123; tmp[k] = arr[j]; // sum += (j - i) - (j - m); j++; k++; &#125; &#125; while (i &lt; m) &#123; tmp[k] = arr[i]; i++; k++; &#125; while (j &lt;= t) &#123; tmp[k] = arr[j]; j++; k++; &#125; System.arraycopy(tmp, 0, arr, s, tmp.length); &#125; （5）快速排序 Quick Sort1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 /** * 获得基础的下标 * @param arr 需要排序的数组 * @param low 数组待排序的最小的下标 * @param high 数组待排序的最大的下标 * @return 返回中轴值（该值大于左边值，小于右边值） */ public static int getMiddle(int[] arr,int low,int high)&#123; int temp = arr[low];// temp = 67 // 67，23，12，11，56，87，23，48，22，18 // 18，23，12，11，56，87，23，48，22，18 // 18，23，12，11，56，87，23，48，22，87 // 18，23，12，11，56，22，23，48，22，87 // 18，23，12，11，56，22，23，48，67，87 while(low &lt;high)&#123;// 0&lt;1 while(low &lt;high &amp;&amp; arr[high] &gt; temp)&#123;//0&lt;1 &amp;&amp; 14&gt;12 high--;//h = 0 &#125; arr[low] = arr[high]; // a[0] = a[0]; while(low &lt;high &amp;&amp; arr[low] &lt;=temp)&#123;// low++; &#125; arr[high] = arr[low];//a[0] = a[0] &#125; arr[low] = temp;//a[0] = 12 return low;// 8 &#125; public static void quickSort(int[] arr,int low, int high)&#123; if(low &lt;high)&#123;//0,1 //将数组一份为二 int middle = getMiddle(arr, low, high);// arr 0,9 m = 8 System.out.println(&quot;middle = &quot; + middle);//m =4 //左边进行递归 快速排序 quickSort(arr,low,middle -1); // arr 0,7 //右边进行递归 快速排序 quickSort(arr,middle + 1,high);// arr 9，9 &#125;&#125;//再次封装，对外调用 12，14public static void quick(int[] arr)&#123; if(arr.length &gt;=2) quickSort(arr, 0, arr.length -1);// 0,9&#125;int[] a =&#123;&#125;int[] a =&#123;65&#125;int[] a =&#123;65,16&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE02基础语法","slug":"JavaSE02基础语法","date":"2021-07-15T06:58:28.000Z","updated":"2021-07-19T11:43:17.437Z","comments":true,"path":"2021/07/15/JavaSE02基础语法/","link":"","permalink":"http://example.com/2021/07/15/JavaSE02%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Java基础语法1. 标识符命名规范（见名思意）： 组成： 只能由字母、数字、下划线、美元$ ； (1)包 package : [模块分类], 字母全部都小写，网站或组织的逆序； (2)类 、接口 ：首字母大写，多个单词之间首字母大写分隔 （驼峰式命名）;不能以数字开头； (3)变量、方法： 首字母小写，多个单词之间首字母大写分隔 （驼峰式命名）;不能以数字开头； (4)常量： [值不能再发生改变的变量], 必须用final 修饰，字母全部都是大写，多个单词之间下划线_ 分隔，必须要赋值； (5)方法： 首字母小写，多个单词之间首字母大写分隔 （驼峰式命名） 可参考《阿里巴巴Java开发手册》 2.关键字 关键字 保留字 goto,const(关键字的候选人) 3.注释1234567单行注释： // 多行注释： /* * */ 文档注释： /** * */ 4.数据类型 基本数据类型(Primitive Type)：byte，short，int，long，float，double，char，boolean 引用数据类型(Reference Type)：类，接口，数组，枚举，注解 ​ 注意：转义字符如：char c1 =’\\b’; ​ 5. 数据类型的相互转换：1)、正向的过程: 从低字节向高字节可以自动转换 （Java中的自动类型提升 ）12345byte-&gt; short-&gt; int-&gt; long-&gt; float-&gt; double 三种情况: int -&gt; float long -&gt; float long -&gt; double 特殊情况：char &lt;-&gt; int （相互转换） 2)、 反向的过程: 从高字节向低字节可以强制转换. 例如: int a = (int) 4.562; 注意: 反向转换将会丢失精度 6 . 运算符与操作符算术运算符 赋值运算符 比较运算符 逻辑运算符 位运算符 类型相关运算符 instance of 注意：1234int a = 10;c = a++ // c = a =10 ; a= a+1 =11c = ++a; // a= a+1 =11; c = 11;就近原则 &amp; | (1)算术运算： 0 &amp; 1 = 0 1 &amp; 0 = 0 1 * 1 = 1 0 &amp; 0 = 0 0 | 1 = 1 1 |0 = 1 1 | 1 = 1 0 | 0 = 0 示例： 3 &amp; 2 = 2； 3 | 2 = 3； （2）逻辑运算 (exp1) &amp; (exp2) : 两个条件必须同时满足,才为true true &amp; true = true; true &amp; false = false; false &amp; true = false; false &amp; false = false; (exp1) | (exp2) : 两个条件有一个为true,值为true true | true = true; true | false = false; false | true = false; false | false = false; 短路与&amp;&amp;， 短路或||12345678910 (exp1) &amp;&amp; (exp2) : 两个条件必须同时满足,才为true true &amp;&amp; true = true;true &amp;&amp; false = false;false &amp;&amp; true = false;false &amp;&amp; false = false; (exp1) || (exp2) : 两个条件有一个为true,值为true true || true = true; true || false = false; false || true = false; false || false = false; 总结 &amp;&amp; 和 &amp; 的区别 ， || 和 | 的区别1234567 (exp1) &amp; (exp2) : exp1,exp2 都要执行 (exp1) | (exp2) : exp1,exp2 都要执行 (exp1) &amp;&amp; (exp2) &amp;&amp; （exp3） 若exp1 表达式返回false， exp2不执行，直接返回结果false(exp1) || (exp2) 若exp1 表达式返回true， exp2不执行，直接返回结果true 7. 流程控制（1）顺序结构 if-else 12345678910111213 if (逻辑表达式) &#123; 语句1； 语句2； …… &#125; if (逻辑表达式)&#123; 语句； &#125;else&#123; 语句； &#125; switch-case switch与case后面的值的数据类型： (能够转换成int类型的值)byte,short,int,char, Byte,Short,Integer,Character, + String + 枚举 123456789101112131415switch(表达式)&#123; case 常量表达式1：语句1 case 常量表达式2：语句2 ...... case 常量表达式n：语句n default: 语句n+1&#125;//case块中不加break时顺序执行下面的语句int day =20;switch( day )&#123; case 1: System.out.println(&quot;星期1&quot;);break; case 2: System.out.println(&quot;星期2&quot;);break; default: System.out.println(&quot;无效的星期&quot;);break;&#125; （2）循环结构 while 123456789while( 逻辑表达式 )&#123; // 返回true才继续循环执行代码块 //代码块&#125;int i =1;while(i&lt;=10)&#123; System.out.print(i); i++;&#125; do-while 12345678910111213do&#123; //代码块&#125;while( 逻辑表达式 )&#123; // 返回true才继续循环执行代码块 示例： int i =0; do&#123; System.out.println(i); i++;&#125; while(i&lt;=10)； for循环 12345for(int i =0;i&lt;10;i++)&#123; // 0-9 System.out.println(i);&#125; 循环嵌套 12345678910111213141516171819202122232425for(int i =1;i&lt;=3;i++)&#123; for(int j =1;j&lt;=2 ;j++)&#123; int m = i * j ; System.out.println(m); &#125; &#125;/* i = 1;i&lt;= 3; true; int j =1; j&lt;=2 true; m = 1*1 = 1; print(m) 1 ; j++ j = 2; j&lt;=2 true; m = 1* 2 = 2; print(m) 2 ;j++ j= 3;j&lt;=2 false 内存循环就结束 i= 2;i&lt;=3 true; int j = 1;j&lt;=2 m =2 *1 = 2 ;j++ j = 2; j&lt;=2 m = 2*2 = 4;j++ j = 3 j&lt;=2 false 内存循环就结束 i= 3; i&lt;=3 true int j = 1;j&lt;=2 m =3 *1 = 3 ;j++ j = 2; j&lt;=2 m = 3*2 = 6;j++ j = 3 j&lt;=2 false 内存循环就结束 i = 4 ; i&lt;=3 false 该循环结束*/ 循环中的关键字 break,continue break : 结束当前循环 continue ： 结束本次循环，继续下一次循环 8.数组一维数组定义：一组相同数据类型数据的集合; 内存地址连续； 长度固定； 下标从0开始 （1）声明数组变量123 数组能以下列形式声明： （数据类型 变量名）int[] myArray ；Product[] proArray ； (2)数组的定义 int[] a =new int[10](数组空间的声明，并把空间首地址赋值给数组的引用) int[] a； a=new int[10]； Product[] proArray = new Product[100]; 上面的语法语句做了两件事: a. 创建了Product类型的，长度为100的数组。 b. 把新创建的数组的引用赋值给变量 proArray 。 (3) 数组创建后有初始值: 整型类型为0 浮点型为0.0 布尔类型为false 字符类型&#39;&#39; 引用类型为null (4)访问数组中的元素 a[8] //访问a数组中下标为8的元素值 (5)获得数组的长度 a.length 注意: 访问没有初始化的数组中的值，是会抛出异常的(NullPointerException）, Java中只保证一维数组的地址是连续的，二维数组实际上是一维数组中有存储了一维数组的引用。 练习：将10个任意小数放置数组中，并将其累加获得总和；获得数组中最大值。foreach循环（JDK1.5引进） 9. 二维数组(1)二维数组定义：（中药店的药柜，电影院的座位）1234567891011121314dataType[][] arrayName = new arrayName[rows][columns];int[][] arr = new int[3][4];//定义了一个存放整型数据的数组，3行4列（即包含三个一维数组，每个一维数组中可以存储4个整数）arr[0][0] = 18;arr[0][1] = 17;arr[0][2] = 33;arr[0][3] = 6;arr[1][0] = 99;arr[1][1] = 23;arr[1][2] = 56;arr[1][3] = 91;arr[2][0] = 76;arr[2][1] = 10;arr[2][2] = 4;arr[2][3] = 7; (2)获得二维数组的长度：arr.length : 获得该二维数组共有几行（共有几个一维数组） arr[0].length:获得该二维数组共有几列（每个一维数组有几个值） (3)Arrays 类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。 练习：数组中查询最大值，最小值，排序","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaSE01环境配置","slug":"JavaSE01环境配置","date":"2021-07-15T06:56:23.000Z","updated":"2021-07-19T11:43:24.286Z","comments":true,"path":"2021/07/15/JavaSE01环境配置/","link":"","permalink":"http://example.com/2021/07/15/JavaSE01%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Java语言概述1 . 安装 JDK (1) 官网下载JDK：http://www.oracle.com/technetwork/java/javase/downloads/index.html (2) 安装JDK：JDK 安装文件可运行于特定的平台, 为了便于设置环境变量，我们将安装到默认的安装目录 (3) JDK文件目录结构 bin:Java 可执行命令 jre: java 运行时环境 lib: （Library 类库）：jdk提供的类与接口的仓库 src.zip:(source):源码包 (4) 设置环境变量：环境变量是操作系统或其他应用程序用于定位JDK操作系统变量,通常建立 12345678编辑 Path : ;C:\\Program Files\\Java\\jdk1.8.0_201\\bin 新建CLASSPATH : .;C:\\Program Files\\Java\\jdk1.6.0_10\\lib 或者新建JAVA_HOME:C:\\Program Files\\Java\\jdk1.8.0_201编辑 Path : ;%JAVA_HOME%\\bin 新建CLASSPATH : .;%JAVA_HOME%\\lib 注意： CLASSPATH中的 点号. : 当前java 命令执行的根目录 2. 第一个Java程序新建文件HelloWorld.java 12345678//1. 文件名必须与类名同名(大小写严格区分)public class HelloWorld&#123; // 2. 主方法的固定写法,,main()运行的入口方法 public static void main(String[] args)&#123; System.out.println(&quot;Hello Smith!&quot;); &#125;&#125;//3.一个文件中可以同时包含多个类，但是只能有一个public修饰的公开类，并且编译后会分别生成相互独立的类(.class字节码文件); 3.分析Java源文件执行原理 4.JDK &amp; JREJDK : Java Development kits (Java开发工具包) JRE: Java Runtime Environment(Java运行时环境) Java 跨平台","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"hexo-day02","slug":"hexo-day02","date":"2021-07-13T06:55:14.000Z","updated":"2021-07-13T06:57:09.323Z","comments":true,"path":"2021/07/13/hexo-day02/","link":"","permalink":"http://example.com/2021/07/13/hexo-day02/","excerpt":"","text":"hexo+github搭建博客服务器 csdn,简书,有道笔记 - 广告比较多 hexo+github[比较慢,翻墙]/gitee[Git pages服务器 - 维护]/阿里云服务器 安装nodejs 非中文的非特殊字符的目录中[目录中不要出现空格或者带有特殊符号的] D:/node-v14.17.3-win-x64 环境变量的配置 桌面计算机 - 右击 - 属性 - 高级系统设置 - 环境变量(N) 定位到下方的系统变量 定位到变量名 - Path - 编辑 - 新建 D:/node-v14.17.3-win-x64 一定要关闭所有的环境变量配置的窗口 - 确定 打开终端[如果终端已经打开了,关闭 - 重新打开] win[微软图标]+r - 输入cmd - 输入如下指令检测nodejs是否配置成功 12345npm -v6.14.5 出现版本号,则说明配置成功 如果出现了不是内部或者外部的命令的同学,请检查自己的nodejs解压缩之后的路径是否成功配置到了path中 简单认识npm npm是javascript的一个**包[前端框架]**管理工具,并且是nodejs平台默认的包管理工具. 通过npm可以安装,共享,分发代码,管理项目依赖关系. 类似于java中的maven或者gradle[强大的项目构建工具以及项目依赖管理工具] npm简单使用修改镜像 为了下载速度变快,修改npm的镜像 1npm config set registry https://registry.npm.taobao.org 验证一下,镜像是否成功修改了 123npm config get registryhttps://registry.npm.taobao.org/ 简单使用 - 不需要操作 下载bootstrap npm install 框架名称 - 默认下载的是最新的版本 1npm install bootstrap@3 Hexo官网 https://hexo.io/zh-cn/docs/ 安装 假设你在D盘根目录下新建了一个文件夹hello-hexo[博客项目的根目录] win+r - 打开终端 通过dos命令进入到hello-hexo目录中 123C:/User/admin&gt;d:D:&gt;cd hello-hexoD:/hello-hexo&gt;npm install hexo-cli -g 创建真正的博客目录1D:/hello-hexo&gt;hexo init hello-blog 12cd hello-blogD:/hello-hexo/hello-blog&gt;npm install 测试 - 启动博客服务器1D:/hello-hexo/hello-blog&gt;hexo s 关闭服务器 1ctrl+c 打开浏览器输入:localhost:4000 常用主题模板 https://blog.csdn.net/zgd826237710/article/details/99671027 使用git命令来进行克隆,需要提前安装好git,检测git是否安装成功,重新打开终端 1git --version 注册码云账号 推荐用QQ注册一下 本地配置码云账号信息 - 配置文件 - 位置windows的用户主目录下 C:/User/计算机用户名 - 观察是否存在**.gitconfig**文件,添加如下内容 123[user] email = 码云的QQ邮箱 name = 用户名 安装模板 通过cmd进入到hello-blog目录中的themes目录中 12D:/hello-hexo/hello-blog&gt;cd themesD://hello-hexo/hello-blog/themes&gt;git clone https://gitee.com/guancg/hexo-theme-pure.git 或者直接从github上直接clone 1git clone https://github.com/cofess/hexo-theme-pure.git 更新主题配置 指定新的主题 hello-blog目录下的_config.yml文件 1theme: hexo-theme-pure 重启服务器hexo s 个人信息hexo-theme-pure/_config.yml文件 12345overriden author: 亲爱的管管 author_title: 高级打字员 author_description: 个人简介。 location: SuZhou, China Markdown语法 语法的编辑器 - https://typora.io/ 文件的后缀是md 1234567891011121314151617181920212223242526272829303132333435常用语法如下:1. 标题的语法:1~6标题 - # 一级标题 ## 二级标题 2. 代码块 - java,js,mysql...​~~~java 敲enter键3. 列表3-1. 无序列表 * 列表名称 有序列表 1. 列表名称4. 高亮显示 `高亮显示内容`5. 加粗字体 **粗体**6. 斜体 *斜体*7. 粗+斜 ***粗斜***8. 段落 &gt; 空格9. 引入外部图片 ![](xx.png)10. 表格 新建博文1D://hello-hexo/hello-blog&gt;hexo n java 效果:hello-blog目录下的source/_ports/自动生成一个java.md文件 重启blog服务器 1D://hello-hexo/hello-blog&gt;hexo s 主题的侧边栏 侧边栏的链接生效 将/hello-blog/themes/hexo-theme-pure/_source/下的除了_data文件夹,其余文件夹 拷贝一份放入到hello-blog目录下的source目录中即可 文章的分类和标签 只需要在文章的.md文件的自动生成的头部添加 1234title: javadate: 2021-07-13 08:44:42categories: javatags: java 博客的语言环境设置 设置中文 hello-blog下的_config.yml文件中 language: zh-CN 图片显示问题 安装插件 - npm install https://gitee.com/guancg/hexo-asset-image.git –save 需要到hello-blog/_config.yml文件中进行配置 1post_asset_folder: true hexo n 机器学习 效果就是除了生成了机器学习.md还有一个机器学习文件夹,那么这篇文章的所有的图片就可以存储在机器学习文件夹中 hexo s 内置搜索的功能 1234# Searchsearch:insight: true # you need to install `hexo-generator-json-content` before using Insight Searchbaidu: false # you need to disable other search engines to use Baidu search 安装内置搜索插件 npm i -S hexo-generator-json-content 评论 不需要本地数据库进行存储的,用的是第三方的. LeanCloud - 官网地址 - https://www.leancloud.cn/ 注册 - 登录 - 控制台 - 创建应用 - 右下设置 - 应用凭证 appId - sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz appKey - 3hn4ijEgSzJeRV4nkmXThmGV 在hexo-theme-pure\\_config.yml文件中配置 12345678910valine: # Valine. https://valine.js.org appid: sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz # your leancloud application appid appkey: 3hn4ijEgSzJeRV4nkmXThmGV# your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style meta: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: true # Article reading statistic https://valine.js.org/visitor.html #字数统计&amp;阅读时长 npm i -S hexo-wordcount hexo-theme-pure_config.yml文件中配置 1234postCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 附件-优秀插件 显示图片 1npm install https://gitee.com/guancg/hexo-asset-image.git --save 内置搜索 1npm i -S hexo-generator-json-content 字数统计&amp;阅读时长 1npm i -S hexo-wordcount github部署 1npm install hexo-deployer-git --save github注册一下 github.com chrome浏览器 + iguge - https://iguge.app/ 新建的仓库的名称必须是guancgsuccess.github.io 仓库地址 - https://github.com/guancgsuccess/guancgsuccess.github.io.git 安装github部署插件 npm install hexo-deployer-git –save hello-blog/_config.yml文件 1234deploy:type: &#x27;git&#x27;repo: &#x27;https://github.com/guancgsuccess/guancgsuccess.github.io.git&#x27;branch: &#x27;master&#x27; hexo三连操作 1234hexo clhexo ghexo shexo d 浏览器输入 - guancgsuccess.github.io","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"hexo_day01","slug":"hexo-day01","date":"2021-07-13T00:26:36.000Z","updated":"2021-07-13T00:56:33.593Z","comments":true,"path":"2021/07/13/hexo-day01/","link":"","permalink":"http://example.com/2021/07/13/hexo-day01/","excerpt":"","text":"hexo+github搭建博客服务器 csdn,简书,有道笔记 - 广告比较多 hexo+github[比较慢,翻墙]/gitee[Git pages服务器 - 维护]/阿里云服务器 安装nodejs 非中文的非特殊字符的目录中[目录中不要出现空格或者带有特殊符号的] D:/node-v14.17.3-win-x64 环境变量的配置 桌面计算机 - 右击 - 属性 - 高级系统设置 - 环境变量(N) 定位到下方的系统变量 定位到变量名 - Path - 编辑 - 新建 D:/node-v14.17.3-win-x64 一定要关闭所有的环境变量配置的窗口 - 确定 打开终端[如果终端已经打开了,关闭 - 重新打开] win[微软图标]+r - 输入cmd - 输入如下指令检测nodejs是否配置成功 12345npm -v6.14.5 出现版本号,则说明配置成功 如果出现了不是内部或者外部的命令的同学,请检查自己的nodejs解压缩之后的路径是否成功配置到了path中 简单认识npm npm是javascript的一个**包[前端框架]**管理工具,并且是nodejs平台默认的包管理工具. 通过npm可以安装,共享,分发代码,管理项目依赖关系. 类似于java中的maven或者gradle[强大的项目构建工具以及项目依赖管理工具] npm简单使用修改镜像 为了下载速度变快,修改npm的镜像 1npm config set registry https://registry.npm.taobao.org 验证一下,镜像是否成功修改了 123npm config get registryhttps://registry.npm.taobao.org/ 简单使用 - 不需要操作 下载bootstrap npm install 框架名称 - 默认下载的是最新的版本 1npm install bootstrap@3 Hexo官网 https://hexo.io/zh-cn/docs/ 安装 假设你在D盘根目录下新建了一个文件夹hello-hexo[博客项目的根目录] win+r - 打开终端 通过dos命令进入到hello-hexo目录中 123C:/User/admin&gt;d:D:&gt;cd hello-hexoD:/hello-hexo&gt;npm install hexo-cli -g 创建真正的博客目录1D:/hello-hexo&gt;hexo init hello-blog 12cd hello-blogD:/hello-hexo/hello-blog&gt;npm install 测试 - 启动博客服务器1D:/hello-hexo/hello-blog&gt;hexo s 关闭服务器 1ctrl+c 打开浏览器输入:localhost:4000 常用主题模板 https://blog.csdn.net/zgd826237710/article/details/99671027 使用git命令来进行克隆,需要提前安装好git,检测git是否安装成功,重新打开终端 1git --version 注册码云账号 推荐用QQ注册一下 本地配置码云账号信息 - 配置文件 - 位置windows的用户主目录下 C:/User/计算机用户名 - 观察是否存在**.gitconfig**文件,添加如下内容 123[user] email = 码云的QQ邮箱 name = 用户名 安装模板 通过cmd进入到hello-blog目录中的themes目录中 12D:/hello-hexo/hello-blog&gt;cd themesD://hello-hexo/hello-blog/themes&gt;git clone https://gitee.com/guancg/hexo-theme-pure.git 或者直接从github上直接clone 1git clone https://github.com/cofess/hexo-theme-pure.git 更新主题配置 指定新的主题 hello-blog目录下的_config.yml文件 1theme: hexo-theme-pure 重启服务器hexo s Markdown语法 语法的编辑器 - https://typora.io/ 文件的后缀是md 1234567891011121314151617181920212223242526272829303132333435常用语法如下:1. 标题的语法:1~6标题 - # 一级标题 ## 二级标题 2. 代码块 - java,js,mysql...​~~~java 敲enter键3. 列表3-1. 无序列表 * 列表名称 有序列表 1. 列表名称4. 高亮显示 `高亮显示内容`5. 加粗字体 **粗体**6. 斜体 *斜体*7. 粗+斜 ***粗斜***8. 段落 &gt; 空格9. 引入外部图片 ![](xx.png)10. 表格 新建博文1D://hello-hexo/hello-blog&gt;hexo n java 效果:hello-blog目录下的source/_ports/自动生成一个java.md文件 重启blog服务器 1D://hello-hexo/hello-blog&gt;hexo s","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-07-12T06:44:42.846Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2021/07/12/hello-world/","link":"","permalink":"http://example.com/2021/07/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}